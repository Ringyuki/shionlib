name: deploy frontend

on:
  push:
    branches: ['main']
    paths:
      - 'apps/frontend/**'
      - 'package.json'
      - 'pnpm-lock.yaml'
      - 'pnpm-workspace.yaml'
      - '.github/workflows/deploy-frontend.yml'
  workflow_dispatch:
    inputs:
      target_environment:
        description: 'Deploy target environment'
        type: choice
        options:
          - staging
          - production
        default: staging
        required: true
      release_ref:
        description: 'Git ref to deploy (branch, tag, or SHA). Leave empty to use current SHA.'
        type: string
        required: false

run-name: frontend deploy to ${{ github.event_name == 'workflow_dispatch' && inputs.target_environment || 'staging' }}

permissions:
  contents: read

concurrency:
  group: shionlib-frontend-deploy-${{ github.event_name == 'workflow_dispatch' && inputs.target_environment || 'staging' }}
  cancel-in-progress: true

jobs:
  checks:
    name: Frontend Checks
    runs-on: ubuntu-latest
    if: github.repository == 'Ringyuki/shionlib' && ((github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch')
    steps:
      - name: Validate dispatch inputs
        if: github.event_name == 'workflow_dispatch'
        run: |
          if [ "${{ inputs.target_environment }}" = "production" ] && [ -z "${{ inputs.release_ref }}" ]; then
            echo "release_ref is required when deploying production"
            exit 1
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.release_ref || github.sha }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install deps
        run: pnpm install --frozen-lockfile

      - name: Format check
        run: pnpm --filter shionlib-frontend format:check

      - name: ESLint
        run: pnpm --filter shionlib-frontend lint

      - name: Type check
        run: pnpm --filter shionlib-frontend typecheck

  build-and-deploy:
    name: Build and Deploy Frontend
    needs: checks
    runs-on: ubuntu-latest
    if: github.repository == 'Ringyuki/shionlib' && ((github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch')
    environment: ${{ (github.event_name == 'workflow_dispatch' && inputs.target_environment == 'production') && 'production-frontend' || 'staging-frontend' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && inputs.release_ref || github.sha }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install deps
        run: pnpm install --frozen-lockfile

      - name: Build frontend
        env:
          NEXT_PUBLIC_PROD_API_PATH: ${{ vars.NEXT_PUBLIC_PROD_API_PATH }}
          INTERNAL_API_PORT: ${{ vars.INTERNAL_API_PORT }}
          INTERNAL_API_BASE_URL: ${{ vars.INTERNAL_API_BASE_URL }}
          NEXT_PUBLIC_SHIONLIB_IMAGE_BED_HOST: ${{ vars.NEXT_PUBLIC_SHIONLIB_IMAGE_BED_HOST }}
          NEXT_PUBLIC_SHIONLIB_IMAGE_BED_URL: ${{ vars.NEXT_PUBLIC_SHIONLIB_IMAGE_BED_URL }}
          NEXT_PUBLIC_UMAMI_SCRIPT_URL: ${{ vars.NEXT_PUBLIC_UMAMI_SCRIPT_URL }}
          NEXT_PUBLIC_UMAMI_WEBSITE_ID: ${{ vars.NEXT_PUBLIC_UMAMI_WEBSITE_ID }}
          NEXT_PUBLIC_OPENPANEL_CLIENT_ID: ${{ vars.NEXT_PUBLIC_OPENPANEL_CLIENT_ID }}
          NEXT_PUBLIC_OPENPANEL_API_URL: ${{ vars.NEXT_PUBLIC_OPENPANEL_API_URL }}
          NEXT_PUBLIC_RYBBIT_SCRIPT_URL: ${{ vars.NEXT_PUBLIC_RYBBIT_SCRIPT_URL }}
          NEXT_PUBLIC_RYBBIT_SITE_ID: ${{ vars.NEXT_PUBLIC_RYBBIT_SITE_ID }}
          NEXT_PUBLIC_TURNSTILE_SITE_KEY: ${{ vars.NEXT_PUBLIC_TURNSTILE_SITE_KEY }}
        run: pnpm --filter shionlib-frontend build

      - name: Compose standalone bundle
        working-directory: apps/frontend
        run: |
          set -euo pipefail

          APP_SERVER_PATH="$(find .next/standalone -type f -path '*/apps/frontend/server.js' | head -n 1)"
          if [ -z "${APP_SERVER_PATH:-}" ]; then
            echo "unable to locate standalone server.js for frontend"
            find .next/standalone -maxdepth 6 -type f | sed -n '1,120p'
            exit 1
          fi

          APP_STANDALONE_DIR="$(dirname "$APP_SERVER_PATH")"
          APP_SERVER_REL_PATH="${APP_SERVER_PATH#.next/standalone/}"

          cp -r public "$APP_STANDALONE_DIR/"
          mkdir -p "$APP_STANDALONE_DIR/.next"
          cp -r .next/static "$APP_STANDALONE_DIR/.next/"

          cat > .next/standalone/server.js <<EOF_STANDALONE_SERVER
          require('./${APP_SERVER_REL_PATH}')
          EOF_STANDALONE_SERVER

      - name: Archive artifact
        working-directory: apps/frontend
        run: |
          DEPLOY_SHA=$(git rev-parse --short=7 HEAD)
          TAR_NAME="frontend-release-${DEPLOY_SHA}.tgz"
          echo "DEPLOY_SHA=$DEPLOY_SHA" >> "$GITHUB_ENV"
          echo "TAR_NAME=$TAR_NAME" >> "$GITHUB_ENV"
          tar -czf "$TAR_NAME" -C . .next

      - name: Install cloudflared
        run: |
          set -e
          mkdir -p /tmp/cloudflared
          curl -sL -o /tmp/cloudflared/cloudflared \
            https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64
          chmod +x /tmp/cloudflared/cloudflared
          /tmp/cloudflared/cloudflared --version

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' "${{ secrets.SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

      - name: Upload to server
        env:
          SSH_PROXY_COMMAND: '/tmp/cloudflared/cloudflared access ssh --id ${{ secrets.SSH_CLOUDFLARED_ID }} --secret ${{ secrets.SSH_CLOUDFLARED_SECRET }} --hostname %h'
        run: |
          scp \
            -i ~/.ssh/id_ed25519 \
            -o StrictHostKeyChecking=no \
            -o ProxyCommand="$SSH_PROXY_COMMAND" \
            -P "${{ secrets.SSH_PORT }}" \
            "apps/frontend/${TAR_NAME}" \
            "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/tmp/${TAR_NAME}"

      - name: Deploy on server
        env:
          SSH_PROXY_COMMAND: '/tmp/cloudflared/cloudflared access ssh --id ${{ secrets.SSH_CLOUDFLARED_ID }} --secret ${{ secrets.SSH_CLOUDFLARED_SECRET }} --hostname %h'
          PM2_ENV: ${{ vars.PM2_ENV }}
        run: |
          ssh \
            -i ~/.ssh/id_ed25519 \
            -o StrictHostKeyChecking=no \
            -o ProxyCommand="$SSH_PROXY_COMMAND" \
            -p "${{ secrets.SSH_PORT }}" \
            "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" \
            "DEPLOY_DIR='${{ secrets.DEPLOY_DIR }}' DEPLOY_SHA='${DEPLOY_SHA}' PM2_ENV='${PM2_ENV}' bash -s" << 'EOF_REMOTE'
          [ -f ~/.bashrc ] && . ~/.bashrc
          [ -f ~/.profile ] && . ~/.profile
          set -euo pipefail

          export NVM_DIR="${NVM_DIR:-$HOME/.nvm}"
          if [ -s "$NVM_DIR/nvm.sh" ]; then
            . "$NVM_DIR/nvm.sh"
            nvm use 24 >/dev/null || true
          fi
          KEEP_RELEASES=5
          PM2_ENV="${PM2_ENV:-production}"

          if ! command -v node >/dev/null 2>&1; then
            echo "node is not available in PATH"
            exit 1
          fi
          if ! command -v pm2 >/dev/null 2>&1; then
            echo "pm2 is not available in PATH"
            exit 1
          fi

          mkdir -p "$DEPLOY_DIR/releases"

          TS_UTC=$(date -u +%Y%m%d%H%M%S)
          RELEASE_NAME="${TS_UTC}-${DEPLOY_SHA}"
          RELEASE_DIR="$DEPLOY_DIR/releases/$RELEASE_NAME"
          SHARED_DIR="$DEPLOY_DIR/shared"

          TAR_NAME="frontend-release-${DEPLOY_SHA}.tgz"
          mkdir -p "$RELEASE_DIR"
          tar -xzf "/tmp/$TAR_NAME" -C "$RELEASE_DIR"
          rm -f "/tmp/$TAR_NAME"

          if [ ! -f "$SHARED_DIR/.env" ]; then
            echo "missing shared env file: $SHARED_DIR/.env"
            exit 1
          fi
          if [ ! -f "$SHARED_DIR/ecosystem.config.cjs" ]; then
            echo "missing pm2 ecosystem file: $SHARED_DIR/ecosystem.config.cjs"
            exit 1
          fi

          ln -sfn "$SHARED_DIR/.env" "$RELEASE_DIR/.env"
          ln -sfn "$SHARED_DIR/.env" "$RELEASE_DIR/.next/standalone/.env"
          ln -sfn "$SHARED_DIR/ecosystem.config.cjs" "$RELEASE_DIR/ecosystem.config.cjs"
          ln -sfn "$RELEASE_DIR" "$DEPLOY_DIR/current"

          cd "$DEPLOY_DIR/current"
          set -a
          . "$RELEASE_DIR/.env"
          set +a
          pm2 restart shionlib-frontend || pm2 start "ecosystem.config.cjs" --env "$PM2_ENV"

          cd "$DEPLOY_DIR/releases"
          ls -1dt */ | tail -n +$((KEEP_RELEASES+1)) | xargs -r rm -rf
          EOF_REMOTE

      - name: Health check
        env:
          SSH_PROXY_COMMAND: '/tmp/cloudflared/cloudflared access ssh --id ${{ secrets.SSH_CLOUDFLARED_ID }} --secret ${{ secrets.SSH_CLOUDFLARED_SECRET }} --hostname %h'
          HEALTHCHECK_URL: ${{ vars.HEALTHCHECK_URL }}
        run: |
          if [ -z "${HEALTHCHECK_URL:-}" ]; then
            echo "HEALTHCHECK_URL is not set"
            exit 1
          fi

          ssh \
            -i ~/.ssh/id_ed25519 \
            -o StrictHostKeyChecking=no \
            -o ProxyCommand="$SSH_PROXY_COMMAND" \
            -p "${{ secrets.SSH_PORT }}" \
            "${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}" \
            "HEALTHCHECK_URL='${HEALTHCHECK_URL}' bash -s" << 'EOF_REMOTE'
          set -euo pipefail
          for i in $(seq 1 30); do
            if curl -fsS --max-time 8 "$HEALTHCHECK_URL" >/dev/null; then
              echo "health check passed"
              exit 0
            fi
            sleep 5
          done
          echo "health check failed: $HEALTHCHECK_URL"
          curl -iS --max-time 8 "$HEALTHCHECK_URL" || true
          exit 1
          EOF_REMOTE
