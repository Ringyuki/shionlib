jest.mock('node:fs/promises', () => ({
  __esModule: true,
  default: {
    stat: jest.fn(),
    open: jest.fn(),
    rm: jest.fn(),
  },
}))

import { MalwareScanCaseStatus, MalwareScanDecisionSource } from '@prisma/client'
import fs from 'node:fs/promises'
import { ShionBizException } from '../../../common/exceptions/shion-business.exception'
import { ShionBizCode } from '../../../shared/enums/biz-code/shion-biz-code.enum'
import { ArchiveStatus } from '../enums/archive-status.enum'
import { S3_UPLOAD_JOB } from '../../upload/constants/upload.constants'
import { MalwareScanCaseService } from './malware-scan-case.service'

const MalwareScanCaseDecision = {
  ALLOW: 'ALLOW',
  DELETE: 'DELETE',
} as const

describe('MalwareScanCaseService', () => {
  const fsMock = fs as unknown as {
    stat: jest.Mock
    open: jest.Mock
    rm: jest.Mock
  }

  const createService = () => {
    const prisma = {
      malwareScanCase: {
        findMany: jest.fn(),
        count: jest.fn(),
        findUnique: jest.fn(),
        update: jest.fn(),
        create: jest.fn(),
      },
      gameDownloadResourceFile: {
        update: jest.fn(),
      },
      user: {
        findMany: jest.fn(),
        findUnique: jest.fn(),
      },
      game: {
        findUnique: jest.fn(),
      },
      $transaction: jest.fn(),
    }

    const configValues = new Map<string, any>([
      ['file_scan.clamscan_scan_log_path', '/var/log/shionlib/scan.log'],
      ['file_scan.malware_review_timeout_hours', 12],
      ['file_scan.malware_auto_delete_review_note', 'timeout auto delete'],
      ['file_scan.malware_auto_ban_threshold', 3],
      ['file_upload.upload_root_dir', '/data/uploads'],
      ['siteUrl', 'https://shionlib.example'],
    ])
    const configService = {
      get: jest.fn((key: string) => configValues.get(key)),
    }

    const activityService = {
      create: jest.fn(),
    }

    const messageService = {
      send: jest.fn(),
    }

    const emailService = {
      sendMalwareScanNotification: jest.fn(),
    }

    const userService = {
      ban: jest.fn(),
    }

    const uploadQuotaService = {
      withdrawUploadQuotaUseAdjustment: jest.fn(),
    }

    const uploadQueue = {
      add: jest.fn(),
    }

    const service = new MalwareScanCaseService(
      prisma as any,
      configService as any,
      activityService as any,
      messageService as any,
      emailService as any,
      userService as any,
      uploadQuotaService as any,
      uploadQueue as any,
    )

    ;(service as any).logger = {
      error: jest.fn(),
      warn: jest.fn(),
      log: jest.fn(),
    }

    return {
      prisma,
      configService,
      activityService,
      messageService,
      emailService,
      userService,
      uploadQuotaService,
      uploadQueue,
      service,
    }
  }

  beforeEach(() => {
    jest.clearAllMocks()
  })

  it('getList builds where and maps bigint file_size to number', async () => {
    const { service, prisma } = createService()
    prisma.malwareScanCase.findMany.mockResolvedValue([
      {
        id: 1,
        file_size: 1234n,
      },
    ])
    prisma.malwareScanCase.count.mockResolvedValue(11)

    const result = await service.getList({
      page: 2,
      pageSize: 5,
      status: MalwareScanCaseStatus.PENDING,
      decision_source: MalwareScanDecisionSource.ADMIN_ALLOW,
      file_id: 100,
      resource_id: 101,
      uploader_id: 102,
      reviewer_id: 103,
      sortBy: 'created',
      sortOrder: 'asc',
    } as any)

    expect(prisma.malwareScanCase.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: {
          status: MalwareScanCaseStatus.PENDING,
          decision_source: MalwareScanDecisionSource.ADMIN_ALLOW,
          file_id: 100,
          resource_id: 101,
          uploader_id: 102,
          reviewed_by: 103,
        },
        orderBy: { created: 'asc' },
        skip: 5,
        take: 5,
      }),
    )
    expect(result.items[0].file_size).toBe(1234)
    expect(result.meta).toEqual({
      totalItems: 11,
      itemCount: 1,
      itemsPerPage: 5,
      totalPages: 3,
      currentPage: 2,
    })
  })

  it('getById throws when case does not exist', async () => {
    const { service, prisma } = createService()
    prisma.malwareScanCase.findUnique.mockResolvedValue(null)

    await expect(service.getById(999)).rejects.toMatchObject({
      code: ShionBizCode.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_NOT_FOUND,
    })
  })

  it('getById maps bigint file_size to number', async () => {
    const { service, prisma } = createService()
    prisma.malwareScanCase.findUnique.mockResolvedValue({
      id: 1,
      file_size: 2048n,
      status: MalwareScanCaseStatus.PENDING,
    })

    const result = await service.getById(1)
    expect(result.file_size).toBe(2048)
  })

  it('review calls reviewCase with mapped decision source and returns latest data', async () => {
    const { service } = createService()
    const reviewCaseSpy = jest.spyOn(service as any, 'reviewCase').mockResolvedValue(undefined)
    jest.spyOn(service, 'getById').mockResolvedValue({ id: 1 } as any)

    const allowResult = await service.review(
      1,
      { decision: MalwareScanCaseDecision.ALLOW } as any,
      { sub: 10 } as any,
    )
    expect(reviewCaseSpy).toHaveBeenCalledWith({
      id: 1,
      dto: { decision: MalwareScanCaseDecision.ALLOW },
      reviewedBy: 10,
      decisionSource: MalwareScanDecisionSource.ADMIN_ALLOW,
    })
    expect(allowResult).toEqual({ id: 1 })

    await service.review(2, { decision: MalwareScanCaseDecision.DELETE } as any, { sub: 11 } as any)
    expect(reviewCaseSpy).toHaveBeenLastCalledWith({
      id: 2,
      dto: { decision: MalwareScanCaseDecision.DELETE },
      reviewedBy: 11,
      decisionSource: MalwareScanDecisionSource.ADMIN_DELETE,
    })
  })

  it('processExpiredCases processes pending items and skips failures', async () => {
    const { service, prisma } = createService()
    prisma.malwareScanCase.findMany.mockResolvedValue([{ id: 1 }, { id: 2 }])
    const reviewCaseSpy = jest
      .spyOn(service as any, 'reviewCase')
      .mockResolvedValueOnce(undefined)
      .mockRejectedValueOnce(new Error('failed'))

    const processed = await service.processExpiredCases()

    expect(processed).toBe(1)
    expect(reviewCaseSpy).toHaveBeenNthCalledWith(1, {
      id: 1,
      dto: {
        decision: MalwareScanCaseDecision.DELETE,
        review_note: 'timeout auto delete',
        notify_uploader: true,
      },
      decisionSource: MalwareScanDecisionSource.TIMEOUT_AUTO_DELETE,
    })
    expect((service as any).logger.error).toHaveBeenCalledWith(
      expect.stringContaining('failed to process expired malware case 2'),
      expect.any(String),
    )
  })

  it('reviewCase(ALLOW) throws when case is missing or already processed', async () => {
    const { service, prisma } = createService()
    const tx = {
      malwareScanCase: {
        findUnique: jest.fn(),
        update: jest.fn(),
      },
      gameDownloadResourceFile: {
        update: jest.fn(),
      },
    }
    prisma.$transaction.mockImplementation(async (cb: any) => cb(tx))

    tx.malwareScanCase.findUnique.mockResolvedValueOnce(null)
    await expect(
      (service as any).reviewCase({
        id: 1,
        dto: { decision: MalwareScanCaseDecision.ALLOW },
        decisionSource: MalwareScanDecisionSource.ADMIN_ALLOW,
      }),
    ).rejects.toMatchObject({
      code: ShionBizCode.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_NOT_FOUND,
    })

    tx.malwareScanCase.findUnique.mockResolvedValueOnce({
      id: 1,
      status: MalwareScanCaseStatus.DELETED,
    })
    await expect(
      (service as any).reviewCase({
        id: 1,
        dto: { decision: MalwareScanCaseDecision.ALLOW },
        decisionSource: MalwareScanDecisionSource.ADMIN_ALLOW,
      }),
    ).rejects.toMatchObject({
      code: ShionBizCode.GAME_DOWNLOAD_RESOURCE_MALWARE_CASE_ALREADY_PROCESSED,
    })
  })

  it('reviewCase(ALLOW) updates file/case, optionally notifies uploader and queues upload', async () => {
    const { service, prisma, activityService, messageService } = createService()
    const tx = {
      malwareScanCase: {
        findUnique: jest.fn(),
        update: jest.fn(),
      },
      gameDownloadResourceFile: {
        update: jest.fn(),
      },
    }
    prisma.$transaction.mockImplementation(async (cb: any) => cb(tx))
    const queueSpy = jest.spyOn(service as any, 'queueS3Upload').mockResolvedValue(undefined)

    tx.malwareScanCase.findUnique.mockResolvedValueOnce({
      id: 10,
      status: MalwareScanCaseStatus.PENDING,
      uploader_id: 8,
      game_id: null,
      file_name: 'safe.7z',
      file: {
        id: 123,
        file_size: 4096n,
        file_name: 'safe.7z',
      },
      resource: {
        game_id: 77,
      },
    })
    await (service as any).reviewCase({
      id: 10,
      dto: {
        decision: MalwareScanCaseDecision.ALLOW,
        review_note: 'ok',
      },
      reviewedBy: 99,
      decisionSource: MalwareScanDecisionSource.ADMIN_ALLOW,
    })

    expect(tx.gameDownloadResourceFile.update).toHaveBeenCalledWith({
      where: { id: 123 },
      data: {
        file_check_status: ArchiveStatus.OK,
        is_virus_false_positive: true,
      },
    })
    expect(activityService.create).toHaveBeenCalledWith(
      expect.objectContaining({
        user_id: 8,
        game_id: 77,
        file_id: 123,
      }),
      tx,
    )
    expect(messageService.send).toHaveBeenCalledWith(
      expect.objectContaining({
        receiver_id: 8,
        meta: expect.objectContaining({
          malware_case_id: 10,
          review_note: 'ok',
        }),
      }),
      tx,
    )
    expect(tx.malwareScanCase.update).toHaveBeenCalledWith(
      expect.objectContaining({
        where: { id: 10 },
        data: expect.objectContaining({
          status: MalwareScanCaseStatus.RELEASED_FALSE_POSITIVE,
          decision_source: MalwareScanDecisionSource.ADMIN_ALLOW,
          reviewed_by: 99,
          notify_uploader_on_allow: true,
        }),
      }),
    )
    expect(queueSpy).toHaveBeenCalledWith(123)

    jest.clearAllMocks()
    tx.malwareScanCase.findUnique.mockResolvedValueOnce({
      id: 11,
      status: MalwareScanCaseStatus.PENDING,
      uploader_id: 9,
      game_id: 3,
      file_name: 'no-file.7z',
      file: null,
      resource: {
        game_id: 3,
      },
    })
    await (service as any).reviewCase({
      id: 11,
      dto: {
        decision: MalwareScanCaseDecision.ALLOW,
        notify_uploader: false,
      },
      decisionSource: MalwareScanDecisionSource.ADMIN_ALLOW,
    })
    expect(activityService.create).not.toHaveBeenCalled()
    expect(messageService.send).not.toHaveBeenCalled()
    expect(queueSpy).not.toHaveBeenCalled()
    expect(tx.malwareScanCase.update).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          notify_uploader_on_allow: false,
          uploader_notified_at: null,
        }),
      }),
    )
  })

  it('reviewCase(DELETE) handles file removal, ban threshold, quota withdraw failure and local cleanup', async () => {
    const { service, prisma, userService, uploadQuotaService, messageService } = createService()
    const tx = {
      malwareScanCase: {
        findUnique: jest.fn(),
        update: jest.fn(),
      },
      user: {
        update: jest.fn(),
      },
      gameDownloadResourceFile: {
        delete: jest.fn(),
        count: jest.fn(),
      },
      gameDownloadResource: {
        delete: jest.fn(),
      },
    }
    prisma.$transaction.mockImplementation(async (cb: any) => cb(tx))
    const removeLocalSpy = jest
      .spyOn(service as any, 'removeLocalFile')
      .mockResolvedValue(undefined)

    tx.malwareScanCase.findUnique.mockResolvedValueOnce({
      id: 20,
      status: MalwareScanCaseStatus.PENDING,
      uploader_id: 1000,
      game_id: 40,
      resource_id: 555,
      file_name: 'infected.7z',
      resource: { id: 555, game_id: 40 },
      file: {
        id: 300,
        file_path: '/data/uploads/infected.7z',
        upload_session_id: 700,
        game_download_resource_id: 555,
      },
    })
    tx.user.update.mockResolvedValueOnce({ upload_injected_file_times: 3 })
    userService.ban.mockRejectedValueOnce(new ShionBizException(ShionBizCode.USER_ALREADY_BANNED))
    tx.gameDownloadResourceFile.count.mockResolvedValueOnce(0)
    uploadQuotaService.withdrawUploadQuotaUseAdjustment.mockRejectedValueOnce(
      new Error('quota fail'),
    )

    await (service as any).reviewCase({
      id: 20,
      dto: {
        decision: MalwareScanCaseDecision.DELETE,
        review_note: 'dangerous',
      },
      reviewedBy: 77,
      decisionSource: MalwareScanDecisionSource.ADMIN_DELETE,
    })

    expect(userService.ban).toHaveBeenCalledWith(
      1000,
      expect.objectContaining({
        banned_reason: 'Uploaded harmful file (3 times)',
        banned_by: 77,
      }),
      tx,
      true,
    )
    expect(tx.gameDownloadResourceFile.delete).toHaveBeenCalledWith({ where: { id: 300 } })
    expect(tx.gameDownloadResource.delete).toHaveBeenCalledWith({ where: { id: 555 } })
    expect(tx.malwareScanCase.update).toHaveBeenCalledWith(
      expect.objectContaining({
        where: { id: 20 },
        data: expect.objectContaining({
          status: MalwareScanCaseStatus.DELETED,
          decision_source: MalwareScanDecisionSource.ADMIN_DELETE,
        }),
      }),
    )
    expect(messageService.send).toHaveBeenCalledWith(
      expect.objectContaining({
        receiver_id: 1000,
        game_id: 40,
      }),
      tx,
    )
    expect((service as any).logger.error).toHaveBeenCalledWith(
      expect.stringContaining(
        'failed to withdraw upload quota for user 1000, session 700: quota fail',
      ),
      expect.any(String),
    )
    expect(removeLocalSpy).toHaveBeenCalledWith('/data/uploads/infected.7z')
  })

  it('reviewCase(DELETE) handles resource-only branch and ban failure propagation', async () => {
    const { service, prisma, userService, uploadQuotaService, messageService } = createService()
    const tx = {
      malwareScanCase: {
        findUnique: jest.fn(),
        update: jest.fn(),
      },
      user: {
        update: jest.fn(),
      },
      gameDownloadResourceFile: {
        delete: jest.fn(),
        count: jest.fn(),
      },
      gameDownloadResource: {
        delete: jest.fn(),
      },
    }
    prisma.$transaction.mockImplementation(async (cb: any) => cb(tx))
    const removeLocalSpy = jest
      .spyOn(service as any, 'removeLocalFile')
      .mockResolvedValue(undefined)

    tx.malwareScanCase.findUnique.mockResolvedValueOnce({
      id: 21,
      status: MalwareScanCaseStatus.PENDING,
      uploader_id: 2000,
      game_id: null,
      resource_id: 556,
      file_name: 'resource-only.7z',
      resource: { id: 556, game_id: 41 },
      file: null,
    })
    tx.user.update.mockResolvedValueOnce({ upload_injected_file_times: 1 })
    tx.gameDownloadResourceFile.count.mockResolvedValueOnce(0)

    await (service as any).reviewCase({
      id: 21,
      dto: {
        decision: MalwareScanCaseDecision.DELETE,
        notify_uploader: false,
      },
      decisionSource: MalwareScanDecisionSource.ADMIN_DELETE,
    })

    expect(messageService.send).not.toHaveBeenCalled()
    expect(uploadQuotaService.withdrawUploadQuotaUseAdjustment).not.toHaveBeenCalled()
    expect(tx.gameDownloadResource.delete).toHaveBeenCalledWith({ where: { id: 556 } })
    expect(removeLocalSpy).toHaveBeenCalledWith(null)

    jest.clearAllMocks()
    tx.malwareScanCase.findUnique.mockResolvedValueOnce({
      id: 22,
      status: MalwareScanCaseStatus.PENDING,
      uploader_id: 3000,
      game_id: 42,
      resource_id: 557,
      file_name: 'ban-fail.7z',
      resource: { id: 557, game_id: 42 },
      file: null,
    })
    tx.user.update.mockResolvedValueOnce({ upload_injected_file_times: 3 })
    userService.ban.mockRejectedValueOnce(new Error('ban failed'))

    await expect(
      (service as any).reviewCase({
        id: 22,
        dto: {
          decision: MalwareScanCaseDecision.DELETE,
        },
        reviewedBy: 1,
        decisionSource: MalwareScanDecisionSource.ADMIN_DELETE,
      }),
    ).rejects.toThrow('ban failed')
  })

  it('registerInfectedFile persists case and notifies admins/uploader', async () => {
    const { service, prisma, activityService, messageService, emailService } = createService()
    const created = {
      id: 55,
      review_deadline: new Date('2026-02-19T00:00:00.000Z'),
      file_name: 'pkg.7z',
      detected_viruses: ['Virus.A', 'Virus.B'],
      game_id: 77,
    }
    const tx = {
      gameDownloadResourceFile: {
        update: jest.fn(),
      },
      malwareScanCase: {
        create: jest.fn().mockResolvedValue(created),
      },
    }
    prisma.$transaction.mockImplementation(async (cb: any) => cb(tx))
    prisma.user.findMany.mockResolvedValue([{ id: 1, email: 'admin@site.test' }])
    prisma.user.findUnique.mockResolvedValue({ id: 88, name: 'uploader' })
    prisma.game.findUnique.mockResolvedValue({
      title_zh: '游戏标题',
      title_jp: null,
      title_en: null,
    })
    jest.spyOn(service as any, 'readScanLogExcerpt').mockResolvedValue('FOUND: pkg.7z Virus.A')

    await service.registerInfectedFile({
      fileId: 99,
      filePath: '/data/uploads/pkg.7z',
      resourceId: 77,
      gameId: 77,
      uploaderId: 88,
      fileName: 'pkg.7z',
      fileSize: 4096,
      fileHash: 'hash-1',
      hashAlgorithm: 'blake3' as any,
      scanResult: { viruses: ['Virus.A', 'Virus.B', 'Virus.A'] },
    })

    expect(tx.gameDownloadResourceFile.update).toHaveBeenCalledWith({
      where: { id: 99 },
      data: {
        file_check_status: ArchiveStatus.HARMFUL_PENDING_REVIEW,
        is_virus_false_positive: false,
      },
    })
    expect(activityService.create).toHaveBeenCalled()
    expect(tx.malwareScanCase.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          file_id: 99,
          detected_viruses: ['Virus.A', 'Virus.B'],
          scan_log_excerpt: 'FOUND: pkg.7z Virus.A',
          file_size: 4096n,
        }),
      }),
    )
    expect(messageService.send).toHaveBeenCalledWith(
      expect.objectContaining({
        receiver_id: 88,
        meta: expect.objectContaining({
          malware_case_id: 55,
          detected_viruses: 'Virus.A, Virus.B',
        }),
      }),
      tx,
    )
    expect(emailService.sendMalwareScanNotification).toHaveBeenCalledWith(
      ['admin@site.test'],
      expect.objectContaining({
        caseId: 55,
        fileName: 'pkg.7z',
      }),
    )
  })

  it('getAdmins filters active admin users', async () => {
    const { service, prisma } = createService()
    prisma.user.findMany.mockResolvedValue([{ id: 1, email: 'a@test.com' }])

    const result = await (service as any).getAdmins()
    expect(result).toEqual([{ id: 1, email: 'a@test.com' }])
    expect(prisma.user.findMany).toHaveBeenCalledWith({
      where: {
        role: { gte: 2 },
        status: 1,
      },
      select: { id: true, email: true },
    })
  })

  it('queueS3Upload enqueues with stable job config', async () => {
    const { service, uploadQueue } = createService()
    await (service as any).queueS3Upload(123)

    expect(uploadQueue.add).toHaveBeenCalledWith(
      S3_UPLOAD_JOB,
      { resourceFileId: 123 },
      {
        jobId: 's3-upload:123',
        attempts: 5,
        backoff: { type: 'exponential', delay: 60_000 },
        removeOnComplete: true,
      },
    )
  })

  it('extractDetectedViruses supports array/string/object inputs', () => {
    const { service } = createService()
    expect((service as any).extractDetectedViruses(null)).toEqual([])
    expect((service as any).extractDetectedViruses({ viruses: [' A ', 'B', 'A'] })).toEqual([
      'A',
      'B',
    ])
    expect((service as any).extractDetectedViruses({ viruses: '  X  ' })).toEqual(['X'])
    expect(
      (service as any).extractDetectedViruses({ viruses: { a: 'v1', b: 'v2', c: 'v1' } }),
    ).toEqual(['v1', 'v2'])
    expect((service as any).extractDetectedViruses({ viruses: 123 })).toEqual([])
  })

  it('toSafeJson normalizes undefined to null-friendly JSON value', () => {
    const { service } = createService()
    expect((service as any).toSafeJson(undefined)).toBe(null)
    expect((service as any).toSafeJson({ a: 1, b: 'x' })).toEqual({ a: 1, b: 'x' })
  })

  it('readScanLogExcerpt extracts matched lines and handles failure', async () => {
    const { service } = createService()
    const close = jest.fn().mockResolvedValue(undefined)
    const read = jest.fn().mockImplementation(async (buffer: Buffer) => {
      buffer.write('line 1\n/data/uploads/pkg.7z FOUND Virus.A\nline 3\n')
      return { bytesRead: buffer.length, buffer }
    })
    fsMock.stat.mockResolvedValueOnce({ size: 64 })
    fsMock.open.mockResolvedValueOnce({ read, close })

    const excerpt = await (service as any).readScanLogExcerpt('/data/uploads/pkg.7z')
    expect(excerpt).toContain('/data/uploads/pkg.7z FOUND Virus.A')

    fsMock.stat.mockRejectedValueOnce(new Error('missing log'))
    await expect(
      (service as any).readScanLogExcerpt('/data/uploads/pkg.7z'),
    ).resolves.toBeUndefined()
  })

  it('removeLocalFile enforces root safety and logs failures', async () => {
    const { service } = createService()

    await (service as any).removeLocalFile(null)
    expect(fsMock.rm).not.toHaveBeenCalled()

    await (service as any).removeLocalFile('/tmp/unsafe.bin')
    expect((service as any).logger.warn).toHaveBeenCalledWith(
      'skip removing unsafe file path: /tmp/unsafe.bin',
    )

    fsMock.rm.mockRejectedValueOnce(new Error('permission denied'))
    await (service as any).removeLocalFile('/data/uploads/safe.bin')
    expect((service as any).logger.warn).toHaveBeenCalledWith(
      'failed to remove local file /data/uploads/safe.bin: permission denied',
    )
  })
})
